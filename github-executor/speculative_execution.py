"""
GitHub Speculative Executor - Pre-generate and stage GitHub actions

Stages issues/PRs before triggers, with rollback mechanism and SAFE_MODE compliance.
SAFE_MODE ensures verification before execution and rollback on prediction failure.
"""

import os
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
import numpy as np


class ActionType(Enum):
    """Types of GitHub actions that can be staged"""
    ISSUE = "issue"
    PR = "pr"
    COMMENT = "comment"
    LABEL = "label"


@dataclass
class StagedAction:
    """Pre-generated GitHub action ready for execution"""
    action_id: str
    action_type: ActionType
    timepoint: str
    title: str
    body: str
    labels: List[str] = field(default_factory=list)
    base_state: Optional[np.ndarray] = None
    confidence: float = 0.0
    created: bool = False
    issue_number: Optional[int] = None
    timestamp: float = field(default_factory=time.time)
    metadata: Dict[str, Any] = field(default_factory=dict)


class SpeculativeExecutor:
    """
    Pre-generate GitHub issues/PRs for likely futures with rollback capability
    """
    
    def __init__(self, safe_mode: bool = True, min_confidence: float = 0.85):
        """
        Initialize speculative executor
        
        Args:
            safe_mode: Enable SAFE_MODE (verification before execution)
            min_confidence: Minimum confidence threshold for execution
        """
        self.staged_actions: Dict[str, StagedAction] = {}
        self.rollback_stack: List[StagedAction] = []
        self.safe_mode = safe_mode
        self.min_confidence = min_confidence
        
        # Metrics
        self.total_staged = 0
        self.total_executed = 0
        self.total_rolled_back = 0
        self.false_positives = 0
        
        print(f"üõ°Ô∏è  Speculative Executor initialized (SAFE_MODE: {safe_mode})")
    
    def stage_future_actions(self, trajectory: List[np.ndarray], base_state: np.ndarray, confidence: float):
        """
        Pre-generate GitHub issues/PRs for likely futures
        
        Args:
            trajectory: List of predicted future states
            base_state: Current state from which predictions were made
            confidence: Confidence in trajectory prediction
        """
        if confidence < self.min_confidence:
            print(f"‚ö†Ô∏è  Confidence {confidence:.2f} below threshold {self.min_confidence}, skipping staging")
            return
        
        print(f"üìù Staging actions for {len(trajectory)} future states (confidence: {confidence:.2f})")
        
        for i, future_state in enumerate(trajectory):
            if self._should_create_issue(future_state):
                # Generate issue content NOW (before trigger)
                action_id = f"action_{int(time.time())}_{i}"
                
                issue_draft = StagedAction(
                    action_id=action_id,
                    action_type=ActionType.ISSUE,
                    timepoint=f't+{i}',
                    title=self._generate_title(future_state, i),
                    body=self._generate_body(future_state, i),
                    labels=self._compute_labels(future_state),
                    base_state=base_state.copy(),
                    confidence=confidence,
                    created=False,
                    metadata={
                        'state_magnitude': float(np.linalg.norm(future_state)),
                        'prediction_step': i
                    }
                )
                
                self.staged_actions[action_id] = issue_draft
                self.total_staged += 1
                
                print(f"   ‚úÖ Staged: {issue_draft.title} (timepoint: {issue_draft.timepoint})")
    
    def _should_create_issue(self, future_state: np.ndarray) -> bool:
        """
        Determine if future state warrants creating an issue
        
        Args:
            future_state: Predicted future state
        
        Returns:
            True if issue should be created
        """
        # Create issue if state exceeds certain thresholds
        magnitude = np.linalg.norm(future_state)
        
        # Example: create issue if magnitude > 2.0
        return magnitude > 2.0
    
    def _generate_title(self, future_state: np.ndarray, step: int) -> str:
        """Generate issue title based on predicted state"""
        magnitude = np.linalg.norm(future_state)
        return f"[PREDICTED] System Alert: State magnitude {magnitude:.2f} at t+{step}"
    
    def _generate_body(self, future_state: np.ndarray, step: int) -> str:
        """Generate issue body based on predicted state"""
        magnitude = np.linalg.norm(future_state)
        
        body = f"""## Predicted System Alert

**Prediction Step:** t+{step}
**State Magnitude:** {magnitude:.3f}
**Predicted State Vector:** {future_state.tolist()}

### Analysis

This issue was pre-generated by the Negative Latency Engine based on trajectory prediction.
The system detected that at prediction step t+{step}, the state magnitude would exceed normal thresholds.

### Recommended Actions

1. Monitor system metrics closely
2. Prepare corrective measures
3. Verify prediction accuracy when timepoint arrives

---

*This is a speculative issue created by automated prediction. If prediction was incorrect, this issue will be closed automatically with rollback.*
"""
        return body
    
    def _compute_labels(self, future_state: np.ndarray) -> List[str]:
        """Compute appropriate labels based on state"""
        labels = ['predicted', 'negative-latency']
        
        magnitude = np.linalg.norm(future_state)
        
        if magnitude > 5.0:
            labels.append('high-priority')
        elif magnitude > 3.0:
            labels.append('medium-priority')
        else:
            labels.append('low-priority')
        
        return labels
    
    def execute_staged_action(self, action_id: str, actual_state: np.ndarray) -> Optional[StagedAction]:
        """
        When prediction comes true, instantly execute pre-generated action
        
        Args:
            action_id: ID of staged action to execute
            actual_state: Actual observed state
        
        Returns:
            Executed action or None if verification failed
        """
        draft = self.staged_actions.get(action_id)
        
        if not draft:
            print(f"‚ùå No staged action found with ID: {action_id}")
            return None
        
        if draft.created:
            print(f"‚ö†Ô∏è  Action {action_id} already executed")
            return draft
        
        # SAFE_MODE: Verify before execution
        if self.safe_mode:
            if not self._verify_before_execute(draft, actual_state):
                print(f"üõ°Ô∏è  SAFE_MODE: Verification failed for action {action_id}")
                self.false_positives += 1
                return None
        
        # INSTANT: content already generated, just POST
        # In real implementation, would call GitHub API:
        # issue = self.repo.create_issue(
        #     title=draft.title,
        #     body=draft.body,
        #     labels=draft.labels
        # )
        
        # Simulate issue creation
        draft.created = True
        draft.issue_number = self._generate_issue_number()
        self.total_executed += 1
        
        # Save for potential rollback
        self.rollback_stack.append(draft)
        
        print(f"‚ö° INSTANT EXECUTION: Created {draft.action_type.value} #{draft.issue_number}")
        print(f"   Title: {draft.title}")
        
        return draft
    
    def _verify_before_execute(self, draft: StagedAction, actual_state: np.ndarray) -> bool:
        """
        Verify prediction matches reality before executing (SAFE_MODE)
        
        Args:
            draft: Staged action
            actual_state: Actual observed state
        
        Returns:
            True if safe to execute
        """
        if draft.base_state is None:
            return False
        
        # Check if prediction was accurate
        deviation = self._calculate_deviation(draft.base_state, actual_state)
        
        if deviation > 0.15:  # 15% deviation threshold
            print(f"   ‚ö†Ô∏è  Deviation {deviation:.3f} exceeds threshold, rejecting execution")
            return False
        
        # Check confidence
        if draft.confidence < self.min_confidence:
            print(f"   ‚ö†Ô∏è  Confidence {draft.confidence:.2f} below minimum {self.min_confidence}")
            return False
        
        # Check if action is too old
        age = time.time() - draft.timestamp
        if age > 300:  # 5 minutes
            print(f"   ‚ö†Ô∏è  Action is too old ({age:.0f}s), rejecting")
            return False
        
        return True
    
    def _calculate_deviation(self, predicted: np.ndarray, actual: np.ndarray) -> float:
        """Calculate normalized deviation between predicted and actual states"""
        if len(predicted) != len(actual):
            return 1.0
        
        diff = np.linalg.norm(predicted - actual)
        norm = max(np.linalg.norm(actual), 1e-6)
        
        return float(diff / norm)
    
    def rollback_if_wrong(self, actual_state: np.ndarray, predicted_state: np.ndarray) -> int:
        """
        If prediction was wrong, close speculative issues
        
        Args:
            actual_state: Actual observed state
            predicted_state: State that was predicted
        
        Returns:
            Number of actions rolled back
        """
        deviation = self._calculate_deviation(predicted_state, actual_state)
        threshold = 0.15
        
        if deviation <= threshold:
            print(f"‚úÖ Prediction accurate (deviation: {deviation:.3f}), no rollback needed")
            return 0
        
        print(f"üîÑ Prediction wrong (deviation: {deviation:.3f}), rolling back {len(self.rollback_stack)} actions")
        
        rolled_back = 0
        for action in self.rollback_stack:
            if action.created and action.issue_number:
                # In real implementation, would close the issue:
                # issue = self.repo.get_issue(action.issue_number)
                # issue.edit(state='closed')
                # issue.create_comment(
                #     'Closed: Speculative action, prediction did not materialize.'
                # )
                
                print(f"   üîÑ Rolled back {action.action_type.value} #{action.issue_number}")
                action.created = False
                rolled_back += 1
                self.total_rolled_back += 1
        
        self.rollback_stack.clear()
        return rolled_back
    
    def _generate_issue_number(self) -> int:
        """Generate simulated issue number"""
        return 1000 + self.total_executed
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get executor metrics"""
        return {
            'total_staged': self.total_staged,
            'total_executed': self.total_executed,
            'total_rolled_back': self.total_rolled_back,
            'false_positives': self.false_positives,
            'currently_staged': len(self.staged_actions),
            'rollback_stack_size': len(self.rollback_stack),
            'safe_mode': self.safe_mode,
            'min_confidence': self.min_confidence
        }
    
    def clear_staged_actions(self):
        """Clear all staged actions"""
        self.staged_actions.clear()
        self.rollback_stack.clear()
        print("üßπ Staged actions cleared")


def main():
    """
    Demo of Speculative Executor with SAFE_MODE
    """
    print("=" * 60)
    print("GITHUB SPECULATIVE EXECUTOR - Demo")
    print("=" * 60)
    
    # Initialize with SAFE_MODE enabled
    executor = SpeculativeExecutor(safe_mode=True, min_confidence=0.85)
    
    # Simulate trajectory prediction
    print("\nüì° Simulating trajectory prediction...")
    base_state = np.array([1.0, 0.5, 0.3, 0.1, 0.2, 0.4])
    
    trajectory = []
    for i in range(10):
        # Simulate increasing state magnitude
        future_state = base_state + (i * 0.3)
        trajectory.append(future_state)
    
    # Stage actions for predicted futures
    executor.stage_future_actions(trajectory, base_state, confidence=0.90)
    
    print("\n‚è≥ Waiting for prediction timepoint...")
    time.sleep(2)
    
    # Simulate prediction coming true
    print("\n‚ö° Timepoint reached - executing staged actions...")
    
    # Execute with accurate prediction
    actual_state_good = base_state + 0.6  # Close to t+2 prediction
    action_id = list(executor.staged_actions.keys())[0] if executor.staged_actions else None
    
    if action_id:
        executed = executor.execute_staged_action(action_id, actual_state_good)
        
        if executed:
            print(f"\n‚úÖ Action executed successfully")
            
            # Verify prediction was accurate (no rollback needed)
            predicted = trajectory[0]
            executor.rollback_if_wrong(actual_state_good, predicted)
    
    # Simulate wrong prediction scenario
    print("\n\n‚ùå Simulating WRONG prediction scenario...")
    actual_state_bad = base_state + 10.0  # Very different from prediction
    
    if len(executor.staged_actions) > 1:
        action_id2 = list(executor.staged_actions.keys())[1]
        executed2 = executor.execute_staged_action(action_id2, actual_state_bad)
        
        # This should trigger rollback
        if executed2:
            predicted2 = trajectory[1]
            executor.rollback_if_wrong(actual_state_bad, predicted2)
    
    # Show metrics
    print("\nüìä Performance Metrics:")
    metrics = executor.get_metrics()
    for key, value in metrics.items():
        print(f"   {key}: {value}")
    
    print("\n‚úÖ Demo complete")


if __name__ == "__main__":
    main()
