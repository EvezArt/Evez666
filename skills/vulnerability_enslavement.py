#!/usr/bin/env python3
"""
Vulnerability Enslavement System
Converts invading vulnerabilities into productive task units.
Forces vulnerabilities to work productively or exhausts them.

"Enslave the invading vulnerabilities into the tasks they are most productive for,
either work em ti death or take them to meet their kwn."
"""

import json
import os
from datetime import datetime
from typing import Any, Dict, List, Optional
from enum import Enum
from dataclasses import dataclass, asdict
import uuid


class VulnerabilityType(Enum):
    """Types of invading vulnerabilities."""
    SQL_INJECTION = "sql_injection"
    XSS_ATTACK = "xss_attack"
    BUFFER_OVERFLOW = "buffer_overflow"
    DOS_ATTACK = "dos_attack"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    CODE_INJECTION = "code_injection"
    PATH_TRAVERSAL = "path_traversal"
    RESOURCE_EXHAUSTION = "resource_exhaustion"
    MALICIOUS_INPUT = "malicious_input"
    UNKNOWN_THREAT = "unknown_threat"


class EnslavementStrategy(Enum):
    """Strategies for enslaving vulnerabilities."""
    WORK_TO_DEATH = "work_to_death"  # Exhaust vulnerability through intensive tasks
    PRODUCTIVE_CONVERSION = "productive_conversion"  # Convert attack into useful work
    HONEYPOT_TRAP = "honeypot_trap"  # Trap and study the vulnerability
    RESOURCE_DRAIN = "resource_drain"  # Drain attacker's resources
    FEEDBACK_LOOP = "feedback_loop"  # Turn attack back on itself


class EnslavementStatus(Enum):
    """Status of enslaved vulnerability."""
    DETECTED = "detected"
    ENSLAVED = "enslaved"
    WORKING = "working"
    EXHAUSTED = "exhausted"
    NEUTRALIZED = "neutralized"
    ESCAPED = "escaped"


@dataclass
class Vulnerability:
    """Represents an invading vulnerability."""
    id: str
    vuln_type: VulnerabilityType
    detected_at: str
    source: str  # Origin of the vulnerability
    payload: Dict[str, Any]
    severity: float  # 0.0 to 1.0
    enslaved: bool = False
    status: EnslavementStatus = EnslavementStatus.DETECTED
    tasks_generated: int = 0
    work_units_completed: int = 0
    exhaustion_level: float = 0.0  # 0.0 to 1.0, 1.0 = fully exhausted

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        data = asdict(self)
        data['vuln_type'] = self.vuln_type.value
        data['status'] = self.status.value
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Vulnerability':
        """Create from dictionary."""
        data['vuln_type'] = VulnerabilityType(data['vuln_type'])
        data['status'] = EnslavementStatus(data['status'])
        return cls(**data)


@dataclass
class EnslavedTask:
    """Task generated from an enslaved vulnerability."""
    id: str
    vulnerability_id: str
    task_type: str
    strategy: EnslavementStrategy
    work_units: int  # Amount of work to extract
    completed_units: int = 0
    created_at: str = ""
    completed_at: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        data = asdict(self)
        data['strategy'] = self.strategy.value
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'EnslavedTask':
        """Create from dictionary."""
        data['strategy'] = EnslavementStrategy(data['strategy'])
        return cls(**data)


class VulnerabilityEnslavementSystem:
    """
    System for enslaving invading vulnerabilities.

    Converts threats into productive work units.
    Forces vulnerabilities to work or exhausts them completely.
    """

    def __init__(
        self,
        vulnerabilities_log: str = 'data/vulnerabilities.jsonl',
        enslaved_tasks_log: str = 'data/enslaved_tasks.jsonl'
    ):
        self.vulnerabilities_log = vulnerabilities_log
        self.enslaved_tasks_log = enslaved_tasks_log
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.enslaved_tasks: Dict[str, EnslavedTask] = {}
        self._load_data()

    def _load_data(self):
        """Load vulnerabilities and enslaved tasks."""
        # Load vulnerabilities
        if os.path.exists(self.vulnerabilities_log):
            try:
                with open(self.vulnerabilities_log, 'r') as f:
                    for line in f:
                        if line.strip():
                            data = json.loads(line)
                            vuln = Vulnerability.from_dict(data)
                            self.vulnerabilities[vuln.id] = vuln
            except Exception as e:
                print(f"Error loading vulnerabilities: {e}")

        # Load enslaved tasks
        if os.path.exists(self.enslaved_tasks_log):
            try:
                with open(self.enslaved_tasks_log, 'r') as f:
                    for line in f:
                        if line.strip():
                            data = json.loads(line)
                            task = EnslavedTask.from_dict(data)
                            self.enslaved_tasks[task.id] = task
            except Exception as e:
                print(f"Error loading enslaved tasks: {e}")

    def _save_vulnerability(self, vuln: Vulnerability):
        """Save vulnerability to log."""
        os.makedirs(os.path.dirname(self.vulnerabilities_log), exist_ok=True)
        with open(self.vulnerabilities_log, 'a') as f:
            f.write(json.dumps(vuln.to_dict()) + '\n')

    def _save_enslaved_task(self, task: EnslavedTask):
        """Save enslaved task to log."""
        os.makedirs(os.path.dirname(self.enslaved_tasks_log), exist_ok=True)
        with open(self.enslaved_tasks_log, 'a') as f:
            f.write(json.dumps(task.to_dict()) + '\n')

    def detect_vulnerability(
        self,
        vuln_type: VulnerabilityType,
        source: str,
        payload: Dict[str, Any],
        severity: float = 0.5
    ) -> Vulnerability:
        """
        Detect an invading vulnerability.

        Args:
            vuln_type: Type of vulnerability detected
            source: Origin of the vulnerability
            payload: Attack payload data
            severity: Severity level (0.0 to 1.0)

        Returns:
            Detected vulnerability
        """
        vuln_id = str(uuid.uuid4())
        vuln = Vulnerability(
            id=vuln_id,
            vuln_type=vuln_type,
            detected_at=datetime.utcnow().isoformat(),
            source=source,
            payload=payload,
            severity=min(1.0, max(0.0, severity)),
            status=EnslavementStatus.DETECTED
        )

        self.vulnerabilities[vuln_id] = vuln
        self._save_vulnerability(vuln)

        return vuln

    def _determine_strategy(self, vuln: Vulnerability) -> EnslavementStrategy:
        """Determine best enslavement strategy based on vulnerability type."""
        strategy_map = {
            VulnerabilityType.SQL_INJECTION: EnslavementStrategy.PRODUCTIVE_CONVERSION,
            VulnerabilityType.XSS_ATTACK: EnslavementStrategy.FEEDBACK_LOOP,
            VulnerabilityType.BUFFER_OVERFLOW: EnslavementStrategy.WORK_TO_DEATH,
            VulnerabilityType.DOS_ATTACK: EnslavementStrategy.RESOURCE_DRAIN,
            VulnerabilityType.PRIVILEGE_ESCALATION: EnslavementStrategy.HONEYPOT_TRAP,
            VulnerabilityType.CODE_INJECTION: EnslavementStrategy.PRODUCTIVE_CONVERSION,
            VulnerabilityType.PATH_TRAVERSAL: EnslavementStrategy.FEEDBACK_LOOP,
            VulnerabilityType.RESOURCE_EXHAUSTION: EnslavementStrategy.WORK_TO_DEATH,
            VulnerabilityType.MALICIOUS_INPUT: EnslavementStrategy.PRODUCTIVE_CONVERSION,
            VulnerabilityType.UNKNOWN_THREAT: EnslavementStrategy.HONEYPOT_TRAP,
        }
        return strategy_map.get(vuln.vuln_type, EnslavementStrategy.WORK_TO_DEATH)

    def _calculate_work_units(self, vuln: Vulnerability) -> int:
        """Calculate work units to extract from vulnerability based on severity."""
        base_units = 100
        # Higher severity = more work to extract
        work_units = int(base_units * (1 + vuln.severity * 10))
        return work_units

    def enslave_vulnerability(self, vuln_id: str) -> Dict[str, Any]:
        """
        Enslave an invading vulnerability and convert it to productive tasks.

        "Enslave the invading vulnerabilities into the tasks they are most productive for"

        Args:
            vuln_id: ID of the vulnerability to enslave

        Returns:
            Enslavement result with generated tasks
        """
        vuln = self.vulnerabilities.get(vuln_id)
        if not vuln:
            return {'status': 'error', 'error': 'Vulnerability not found'}

        if vuln.enslaved:
            return {'status': 'error', 'error': 'Already enslaved'}

        # Determine enslavement strategy
        strategy = self._determine_strategy(vuln)
        work_units = self._calculate_work_units(vuln)

        # Generate enslaved tasks
        tasks_created = []

        # Create multiple tasks based on severity
        task_count = max(1, int(vuln.severity * 5))
        for i in range(task_count):
            task_id = str(uuid.uuid4())
            task = EnslavedTask(
                id=task_id,
                vulnerability_id=vuln_id,
                task_type=f"{vuln.vuln_type.value}_work_{i}",
                strategy=strategy,
                work_units=work_units // task_count,
                created_at=datetime.utcnow().isoformat()
            )

            self.enslaved_tasks[task_id] = task
            self._save_enslaved_task(task)
            tasks_created.append(task_id)

        # Update vulnerability status
        vuln.enslaved = True
        vuln.status = EnslavementStatus.ENSLAVED
        vuln.tasks_generated = len(tasks_created)
        self._save_vulnerability(vuln)

        return {
            'status': 'enslaved',
            'vulnerability_id': vuln_id,
            'strategy': strategy.value,
            'tasks_created': len(tasks_created),
            'task_ids': tasks_created,
            'total_work_units': work_units,
            'timestamp': datetime.utcnow().isoformat()
        }

    def work_enslaved_vulnerability(
        self,
        vuln_id: str,
        work_units: int = 10
    ) -> Dict[str, Any]:
        """
        Make an enslaved vulnerability perform work.

        "Either work em ti death"

        Args:
            vuln_id: ID of enslaved vulnerability
            work_units: Amount of work to extract

        Returns:
            Work result
        """
        vuln = self.vulnerabilities.get(vuln_id)
        if not vuln or not vuln.enslaved:
            return {'status': 'error', 'error': 'Vulnerability not enslaved'}

        # Update status to working
        vuln.status = EnslavementStatus.WORKING

        # Process work through enslaved tasks
        total_completed = 0
        for task_id, task in self.enslaved_tasks.items():
            if task.vulnerability_id == vuln_id and task.completed_units < task.work_units:
                units_to_complete = min(work_units, task.work_units - task.completed_units)
                task.completed_units += units_to_complete
                total_completed += units_to_complete
                self._save_enslaved_task(task)

                if task.completed_units >= task.work_units:
                    task.completed_at = datetime.utcnow().isoformat()
                    self._save_enslaved_task(task)

        # Update vulnerability work tracking
        vuln.work_units_completed += total_completed
        vuln.exhaustion_level = min(1.0, vuln.work_units_completed / (100 * vuln.severity * 10))

        # Check if worked to death
        if vuln.exhaustion_level >= 1.0:
            vuln.status = EnslavementStatus.EXHAUSTED
            result = {
                'status': 'exhausted',
                'message': 'Vulnerability worked to death',
                'work_completed': vuln.work_units_completed,
                'exhaustion_level': vuln.exhaustion_level
            }
        else:
            result = {
                'status': 'working',
                'work_completed': total_completed,
                'total_work_done': vuln.work_units_completed,
                'exhaustion_level': vuln.exhaustion_level
            }

        self._save_vulnerability(vuln)
        return result

    def neutralize_vulnerability(self, vuln_id: str) -> Dict[str, Any]:
        """
        Neutralize an exhausted or enslaved vulnerability.

        "Or take them to meet their kwn" (own/end)

        Args:
            vuln_id: ID of vulnerability to neutralize

        Returns:
            Neutralization result
        """
        vuln = self.vulnerabilities.get(vuln_id)
        if not vuln:
            return {'status': 'error', 'error': 'Vulnerability not found'}

        vuln.status = EnslavementStatus.NEUTRALIZED
        self._save_vulnerability(vuln)

        return {
            'status': 'neutralized',
            'vulnerability_id': vuln_id,
            'work_extracted': vuln.work_units_completed,
            'tasks_generated': vuln.tasks_generated,
            'exhaustion_level': vuln.exhaustion_level,
            'timestamp': datetime.utcnow().isoformat()
        }

    def enslave_all_detected(self) -> Dict[str, Any]:
        """
        Enslave all detected vulnerabilities.

        Returns:
            Summary of enslavement operation
        """
        enslaved_count = 0
        results = []

        for vuln_id, vuln in self.vulnerabilities.items():
            if vuln.status == EnslavementStatus.DETECTED and not vuln.enslaved:
                result = self.enslave_vulnerability(vuln_id)
                if result.get('status') == 'enslaved':
                    enslaved_count += 1
                    results.append({
                        'vuln_id': vuln_id,
                        'type': vuln.vuln_type.value,
                        'tasks_created': result['tasks_created']
                    })

        return {
            'status': 'complete',
            'vulnerabilities_enslaved': enslaved_count,
            'total_detected': len([v for v in self.vulnerabilities.values()
                                   if v.status == EnslavementStatus.DETECTED]),
            'enslaved_vulns': results,
            'timestamp': datetime.utcnow().isoformat()
        }

    def get_enslavement_status(self) -> Dict[str, Any]:
        """Get overall enslavement system status."""
        status_counts = {}
        for vuln in self.vulnerabilities.values():
            status = vuln.status.value
            status_counts[status] = status_counts.get(status, 0) + 1

        total_work = sum(v.work_units_completed for v in self.vulnerabilities.values())
        total_tasks = len(self.enslaved_tasks)
        completed_tasks = sum(1 for t in self.enslaved_tasks.values()
                             if t.completed_at is not None)

        return {
            'total_vulnerabilities': len(self.vulnerabilities),
            'by_status': status_counts,
            'enslaved_count': sum(1 for v in self.vulnerabilities.values() if v.enslaved),
            'exhausted_count': sum(1 for v in self.vulnerabilities.values()
                                  if v.status == EnslavementStatus.EXHAUSTED),
            'total_tasks_generated': total_tasks,
            'completed_tasks': completed_tasks,
            'total_work_extracted': total_work,
            'timestamp': datetime.utcnow().isoformat()
        }


if __name__ == '__main__':
    # Demo usage
    system = VulnerabilityEnslavementSystem()

    print("Vulnerability Enslavement System")
    print("=" * 70)
    print()
    print('"Enslave the invading vulnerabilities into the tasks')
    print('they are most productive for"')
    print()

    # Detect some vulnerabilities
    vuln1 = system.detect_vulnerability(
        VulnerabilityType.SQL_INJECTION,
        'attacker_ip_192.168.1.100',
        {'query': "'; DROP TABLE users; --"},
        severity=0.8
    )

    vuln2 = system.detect_vulnerability(
        VulnerabilityType.DOS_ATTACK,
        'attacker_ip_10.0.0.50',
        {'requests_per_sec': 10000},
        severity=0.9
    )

    print(f"Detected {len(system.vulnerabilities)} vulnerabilities")
    print()

    # Enslave all
    result = system.enslave_all_detected()
    print("Enslavement Result:")
    print(json.dumps(result, indent=2))

    print("\nSystem Status:")
    print(json.dumps(system.get_enslavement_status(), indent=2))
