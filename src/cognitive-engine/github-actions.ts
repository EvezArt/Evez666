/**
 * LORD to GitHub Action Layer
 * 
 * Transforms LORD control policies into concrete GitHub actions
 * (issues, labels, PR assignments, etc.)
 */

import { ControlPolicy, PolicyAction, FusionState } from './lord-protocol';

/**
 * GitHub action result
 */
export interface GitHubActionResult {
  success: boolean;
  action: string;
  details: any;
  error?: string;
}

/**
 * GitHub API client interface (to be implemented with actual API calls)
 */
export interface GitHubClient {
  createIssue(title: string, body: string, labels?: string[]): Promise<any>;
  addLabels(issueNumber: number, labels: string[]): Promise<any>;
  assignCopilot(issueNumber: number): Promise<any>;
  createComment(issueNumber: number, body: string): Promise<any>;
  createPullRequest(title: string, body: string, head: string, base: string): Promise<any>;
}

/**
 * Control policy executor
 * 
 * Executes control policies by making actual GitHub API calls
 */
export class PolicyExecutor {
  private client: GitHubClient;
  
  constructor(client: GitHubClient, _repoOwner: string, _repoName: string) {
    this.client = client;
  }
  
  /**
   * Execute a control policy
   */
  async executePolicy(policy: ControlPolicy): Promise<GitHubActionResult[]> {
    const results: GitHubActionResult[] = [];
    
    for (const action of policy.actions) {
      try {
        const result = await this.executeAction(action, policy);
        results.push(result);
      } catch (error) {
        results.push({
          success: false,
          action: action.type,
          details: action.payload,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }
    
    return results;
  }
  
  /**
   * Execute a single policy action
   */
  private async executeAction(
    action: PolicyAction,
    policy: ControlPolicy
  ): Promise<GitHubActionResult> {
    switch (action.type) {
      case 'create_issue':
        return this.executeCreateIssue(action, policy);
      
      case 'label_issue':
        return this.executeLabelIssue(action);
      
      case 'assign_copilot':
        return this.executeAssignCopilot(action);
      
      case 'refactor_proposal':
        return this.executeRefactorProposal(action, policy);
      
      case 'stabilize':
        return this.executeStabilize(action, policy);
      
      case 'log':
        return this.executeLog(action);
      
      default:
        throw new Error(`Unknown action type: ${action.type}`);
    }
  }
  
  /**
   * Create a new issue
   */
  private async executeCreateIssue(
    action: PolicyAction,
    _policy: ControlPolicy
  ): Promise<GitHubActionResult> {
    const { title, body, labels } = action.payload;
    
    const issue = await this.client.createIssue(
      title || 'Cognitive Engine Alert',
      body || 'Alert from Cognitive Engine',
      labels || []
    );
    
    return {
      success: true,
      action: 'create_issue',
      details: { issueNumber: issue.number, url: issue.html_url },
    };
  }
  
  /**
   * Add labels to an existing issue
   */
  private async executeLabelIssue(action: PolicyAction): Promise<GitHubActionResult> {
    const { issueNumber, labels } = action.payload;
    
    await this.client.addLabels(issueNumber, labels);
    
    return {
      success: true,
      action: 'label_issue',
      details: { issueNumber, labels },
    };
  }
  
  /**
   * Assign issue to Copilot
   */
  private async executeAssignCopilot(action: PolicyAction): Promise<GitHubActionResult> {
    const { issueNumber } = action.payload;
    
    await this.client.assignCopilot(issueNumber);
    
    return {
      success: true,
      action: 'assign_copilot',
      details: { issueNumber },
    };
  }
  
  /**
   * Create a refactor proposal (as an issue or PR)
   */
  private async executeRefactorProposal(
    action: PolicyAction,
    _policy: ControlPolicy
  ): Promise<GitHubActionResult> {
    const { module, reason, targetRecursion } = action.payload;
    
    const title = `[Refactor] ${module}: Raise recursion to level ${targetRecursion}`;
    const body = `
## Refactor Proposal

**Module**: ${module}
**Target Recursion**: ${targetRecursion}
**Urgency**: ${_policy.urgency}

### Reason
${reason}

### Proposed Changes
Add a new abstraction layer in module ${module} to increase code recursion depth.

### Expected Outcomes
- Improved code organization
- Better separation of concerns
- Higher system recursion level
- Enhanced crystallization potential

---
*This proposal was generated by the Cognitive Engine based on system metrics.*
    `.trim();
    
    const issue = await this.client.createIssue(title, body, [
      'task:refactor',
      'cognitive-engine',
      `urgency:${_policy.urgency}`,
    ]);
    
    return {
      success: true,
      action: 'refactor_proposal',
      details: { issueNumber: issue.number, module, targetRecursion },
    };
  }
  
  /**
   * Create a stabilization task
   */
  private async executeStabilize(
    action: PolicyAction,
    _policy: ControlPolicy
  ): Promise<GitHubActionResult> {
    const { area, issues } = action.payload;
    
    const title = `[Stabilize] ${area}`;
    const body = `
## Stabilization Task

**Area**: ${area}
**Urgency**: ${_policy.urgency}
**Loop Type**: ${_policy.loopType || 'none'}

### Issues Detected
${issues.map((i: string) => `- ${i}`).join('\n')}

### Recommended Actions
1. Review and fix critical issues
2. Improve test coverage
3. Reduce technical debt
4. Enhance code crystallization

---
*This task was generated by the Cognitive Engine based on system metrics.*
    `.trim();
    
    const issue = await this.client.createIssue(title, body, [
      'task:stabilize',
      'cognitive-engine',
      `urgency:${_policy.urgency}`,
    ]);
    
    return {
      success: true,
      action: 'stabilize',
      details: { issueNumber: issue.number, area },
    };
  }
  
  /**
   * Log action (console or persistent logging)
   */
  private async executeLog(action: PolicyAction): Promise<GitHubActionResult> {
    const { level, message } = action.payload;
    
    // In a real implementation, this would write to a log file or logging service
    console.log(`[${level.toUpperCase()}] ${message}`);
    
    return {
      success: true,
      action: 'log',
      details: { level, message },
    };
  }
}

/**
 * Policy generator
 * 
 * Generates control policies based on system state and divine gap
 */
export class PolicyGenerator {
  /**
   * Generate a control policy from fusion state
   */
  generatePolicy(
    state: FusionState,
    deltaOmega: number,
    urgency: 'low' | 'medium' | 'high' | 'critical'
  ): ControlPolicy {
    const actions: PolicyAction[] = [];
    
    // High urgency: create stabilization tasks
    if (urgency === 'critical' || urgency === 'high') {
      if (state.hazards.activeCount > 0) {
        actions.push({
          type: 'stabilize',
          payload: {
            area: 'Critical Systems',
            issues: [
              `${state.hazards.activeCount} active hazards detected`,
              `Hazard severity: ${state.hazards.severity}`,
            ],
          },
        });
      }
      
      if (state.crystallization.progress < 50) {
        actions.push({
          type: 'stabilize',
          payload: {
            area: 'Code Crystallization',
            issues: [
              `Low crystallization progress: ${state.crystallization.progress.toFixed(1)}%`,
              `Velocity: ${state.crystallization.velocity.toFixed(2)}`,
            ],
          },
        });
      }
    }
    
    // Large positive gap: system below optimum
    if (deltaOmega > 10) {
      const targetRecursion = Math.min(20, state.meta.recursionLevel + 2);
      actions.push({
        type: 'refactor_proposal',
        payload: {
          module: 'Core Systems',
          reason: `System operating below Divine Optimum (ΔΩ = ${deltaOmega.toFixed(1)}). Increasing recursion may improve correction rate.`,
          targetRecursion,
        },
      });
    }
    
    // Large negative gap: system over-correcting
    if (deltaOmega < -10) {
      actions.push({
        type: 'create_issue',
        payload: {
          title: '[Control] System Over-Correction Detected',
          body: `System is over-correcting (ΔΩ = ${deltaOmega.toFixed(1)}). Consider reducing correction pressure.`,
          labels: ['cognitive-engine', 'control-loop'],
        },
      });
    }
    
    // Low crystallization with high recursion: worth loop
    if (state.meta.recursionLevel > 12 && state.crystallization.progress < 40) {
      actions.push({
        type: 'create_issue',
        payload: {
          title: '[Worth Loop] High Recursion Without Crystallization',
          body: `System at recursion level ${state.meta.recursionLevel} but crystallization only ${state.crystallization.progress.toFixed(1)}%. Focus on stabilization before adding complexity.`,
          labels: ['cognitive-engine', 'loop:worth'],
        },
      });
    }
    
    // Always log the policy generation
    actions.push({
      type: 'log',
      payload: {
        level: 'info',
        message: `Policy generated: ${actions.length - 1} actions, urgency=${urgency}, ΔΩ=${deltaOmega.toFixed(1)}`,
      },
    });
    
    return {
      targetRecursionLevel: state.meta.recursionLevel,
      mode: state.meta.entityType,
      urgency,
      reason: `ΔΩ = ${deltaOmega.toFixed(1)}, ${state.hazards.activeCount} hazards`,
      actions,
    };
  }
}
